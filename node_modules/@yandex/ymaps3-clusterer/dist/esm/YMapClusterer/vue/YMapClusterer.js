import { THROTTLE_DEFAULT_TIMEOUT_MS } from '../constants';
export const YMapClustererVuefyOptions = {
    props: {
        method: { type: Object, required: true },
        features: { type: Array, required: true },
        marker: Function,
        cluster: Function,
        tickTimeout: { type: Number, default: THROTTLE_DEFAULT_TIMEOUT_MS },
        onRender: Function,
        maxZoom: { type: Number }
    }
};
export const YMapClustererVuefyOverride = (YMapClustererI, props, { vuefy, Vue }) => {
    const YMapClustererV = vuefy.entity(YMapClustererI, props);
    const YMapCollectionV = vuefy.entity(ymaps3.YMapCollection);
    return Vue.defineComponent({
        name: 'YMapClustererContainer',
        props,
        slots: Object,
        setup(props, { slots }) {
            const clustersVNode = Vue.ref(null);
            const onRender = (clusters) => {
                const vueClusters = {};
                clusters.forEach(({ lnglat, features, clusterId }) => {
                    var _a, _b;
                    vueClusters[clusterId] = Vue.h(Vue.Fragment, { key: clusterId }, features.length === 1
                        ? (_a = slots.marker) === null || _a === void 0 ? void 0 : _a.call(slots, { feature: features[0] })
                        : (_b = slots.cluster) === null || _b === void 0 ? void 0 : _b.call(slots, { coordinates: lnglat, features }));
                });
                clustersVNode.value = Object.values(vueClusters);
                return false;
            };
            return () => [
                Vue.h(YMapClustererV, { ...props, onRender }),
                Vue.h(YMapCollectionV, () => clustersVNode.value)
            ];
        }
    });
};
