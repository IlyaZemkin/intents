var _a, _b, _c;
import { THROTTLE_DEFAULT_TIMEOUT_MS } from './constants';
import { throttle } from './helpers/throttle';
import { YMapClustererReactifyOverride } from './react/YMapClusterer';
import { YMapClustererVuefyOverride, YMapClustererVuefyOptions } from './vue/YMapClusterer';
const defaultProps = Object.freeze({
    tickTimeout: THROTTLE_DEFAULT_TIMEOUT_MS
});
/**
 * Display clustered features on a map.
 *
 * @example
 * ```javascript
 * const clusterer = new YMapClusterer({
 *      method: clusterByGrid({gridSize: 64}),
 *      features: POINTS,
 *      marker: (feature) => new YMapMarker({
 *          coordinates: feature.geometry.coordinates,
 *          source: 'my-source'
 *      }
 *      cluster: (coordinates, cluster) => new YMapMarker({
 *          coordinates,
 *          source: 'my-source'
 *      }
 * });
 *
 * map.addChild(new YMapDefaultSchemeLayer())
 *      .addChild(new YMapFeatureDataSource({id: 'my-source'}))
 *      .addChild(new YMapLayer({source: 'my-source', type: 'markers'}))
 *      .addChild(clusterer);
 * ```
 */
class YMapClusterer extends ymaps3.YMapComplexEntity {
    constructor(props) {
        super(props);
        /** All created entities with cluster id*/
        this._entitiesCache = {};
        /** Viewport entities with cluster id */
        this._visibleEntities = {};
        this._render = this._render.bind(this);
    }
    /**
     * Compare feature coordinates with bounds.
     * Visible in x2 bounds.
     *
     * @param feature
     * @param bounds
     * @param projection
     * @returns either feature belongs to viewport or not
     */
    _isVisible(feature, bounds, projection) {
        const { x, y } = projection.toWorldCoordinates(feature.geometry.coordinates);
        const { x: x1, y: y1 } = projection.toWorldCoordinates(bounds[0]);
        const { x: x2, y: y2 } = projection.toWorldCoordinates(bounds[1]);
        const boundsWidth = x2 - x1;
        const boundsHeight = y1 - y2;
        return (x1 - boundsWidth / 2 <= x &&
            x2 + boundsWidth / 2 >= x &&
            y1 + boundsHeight / 2 >= y &&
            y2 - boundsHeight / 2 <= y);
    }
    /**
     * Get entity from store or create it
     *
     * @param feature
     * @param entityId
     * @param length count of entities in the cluster
     * @returns ready to add to map entity
     */
    _getEntity({ lnglat, features, clusterId: entityId }) {
        let entity = this._entitiesCache[entityId];
        if (!entity) {
            if (features.length === 1) {
                entity = this._props.marker(features[0]);
            }
            else {
                entity = this._props.cluster(lnglat, features);
            }
            this._entitiesCache[entityId] = entity;
        }
        return entity;
    }
    /**
     * Generate map of new entities based on returned from method objects
     *
     * @param nextViewportObjects clustered objects
     * @returns map of entities for new render
     */
    _getVisibleEntities(nextViewportObjects) {
        const nextVisibleEntities = {};
        nextViewportObjects.forEach((object) => {
            const entity = this._getEntity(object);
            nextVisibleEntities[object.clusterId] = entity;
        });
        return nextVisibleEntities;
    }
    /**
     * Removes unnecessary entities and adds new to the map
     *
     * @param nextVisibleEntities new entities for matching with existing entities
     */
    _syncVisibleEntities(nextVisibleEntities) {
        for (const entityId in this._visibleEntities) {
            if (!nextVisibleEntities[entityId]) {
                this._container.removeChild(this._visibleEntities[entityId]);
            }
        }
        for (const entityId in nextVisibleEntities) {
            if (!this._visibleEntities[entityId]) {
                this._container.addChild(nextVisibleEntities[entityId]);
            }
        }
    }
    _render({ mapInAction } = {}) {
        const map = this.root;
        if (!map || mapInAction)
            return;
        const visibleFeatures = this._props.features.filter((feature) => this._isVisible(feature, map.bounds, map.projection));
        let nextViewportObjects;
        if (this._props.maxZoom && map.zoom > this._props.maxZoom) {
            nextViewportObjects = visibleFeatures.map((feature) => ({
                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),
                lnglat: feature.geometry.coordinates,
                clusterId: feature.id,
                features: [feature]
            }));
        }
        else {
            nextViewportObjects = this._props.method.render({
                map,
                features: visibleFeatures
            });
        }
        if (this._props.onRender && this._props.onRender(nextViewportObjects) === false) {
            return;
        }
        const nextVisibleEntities = this._getVisibleEntities(nextViewportObjects);
        this._syncVisibleEntities(nextVisibleEntities);
        this._visibleEntities = nextVisibleEntities;
    }
    _onAttach() {
        this._entitiesCache = {};
        this._visibleEntities = {};
        this._container = new ymaps3.YMapCollection({});
        this.addChild(this._container);
        const onUpdateRender = this._props.tickTimeout ? throttle(this._render, this._props.tickTimeout) : this._render;
        this._mapListener = new ymaps3.YMapListener({ onUpdate: onUpdateRender, onResize: onUpdateRender });
        this.addChild(this._mapListener);
        this._render();
    }
    _onDetach() {
        this.removeChild(this._container);
        this.removeChild(this._mapListener);
        this._entitiesCache = {};
        this._visibleEntities = {};
    }
    _onUpdate() {
        this._render();
    }
}
_a = ymaps3.overrideKeyReactify, _b = ymaps3.overrideKeyVuefy, _c = ymaps3.optionsKeyVuefy;
YMapClusterer.defaultProps = defaultProps;
/** @internal */
YMapClusterer[_a] = YMapClustererReactifyOverride;
YMapClusterer[_b] = YMapClustererVuefyOverride;
YMapClusterer[_c] = YMapClustererVuefyOptions;
export { YMapClusterer };
